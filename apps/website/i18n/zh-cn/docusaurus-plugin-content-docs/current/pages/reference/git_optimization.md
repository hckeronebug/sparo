---
title: Git 优化
---

默认情况下，`git clone` 将下载 Git 仓库中的每个文件，以及每个文件的完整历史记录。对于小型仓库来说，这不是什么大问题。但随着您的 monorepo 累积项目和多年的历史记录，Git 操作会变得越来越慢，直到有一天 `git status` 需要 10 秒或更长时间。该怎么办？

Git 提供了这些基本解决方案，适用于中型仓库并且易于使用：

- **浅克隆 (Shallow clone)** 允许只克隆几个提交，但通常仅适用于一次性克隆，例如 CI 任务。

- **部分克隆 (Partial clone)** 允许在不包含文件内容（**无 Blob** 克隆）甚至提交详细信息（**无树** 克隆）的情况下进行克隆，大大加快了 `git clone` 的时间，并允许在 `git checkout` 期间获取这些详细信息。

- **大文件存储 (LFS)** 可以将二进制文件移动到单独的服务器，在签出时按需下载。然而，LFS 的配置非常复杂，如果配置不当，可能会导致更差的性能。

然而，要在大型仓库中实现良好的性能，需要使用更复杂的 Git 功能，例如：

- Git **文件系统监视器** 和 **后台维护** 是监视更改并定期预取服务器数据的后台进程。用户必须手动注册/注销工作目录，并记得在不需要时“暂停”服务。

- **Git 工作树 (worktrees)** 允许在您的计算机上使用多个工作目录共享一个 `.git` 文件夹，避免了多次克隆的成本。然而，这一功能也有一些尴尬的限制，例如同一个分支不能在两个工作树中签出，并且 Git 钩子也是共享的。

- **稀疏签出 (Sparse checkout)** 允许 `git checkout` 提取文件的子集，而不是整个目录结构。结合部分克隆，稀疏签出是 Git 优化的“战斧”：尽管无关的项目和历史会积累，但您的等待时间将与您实际需要的文件成正比。
